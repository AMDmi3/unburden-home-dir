#!/usr/bin/perl -l
#
# This file causes a list of directories to be removed or moved off
# the users home directory into a given other directory. Usually this
# is used to relief NFS home directories of the burden of caches and
# other performance needing directories.
#
# Copyright (C) 2010 by Axel Beckert <beckert@phys.ethz.ch>,
# Department of Physics, ETH Zurich.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see http://www.gnu.org/licenses/.
#

use strict;
use warnings;

# Configuration variables to be used in configuration files
my $TARGETDIR  = '/tmp';
my $FILELAYOUT = '.unburden-%u/%s';

# Should only be used in configuration files to enable debugging. Not
# set by default to let wrapper scripts set it, too.
my $DEBUG = undef;

# Probably should never be used in configuration files. If you use it
# there, you are mostly on your own.
my $BASENAME = 'unburden_home_dir';

# Load Modules
use Config::Simple;
use Getopt::Std;
use File::Path qw(make_path remove_tree);
use File::Basename;
use File::Touch;
use File::Copy;

# Declare and initialise some variables
my %CONFIG = ();
my %OPTIONS = ();

# Check for a system wide configuration file
if ( -e "/etc/$BASENAME" ) {
    my $cfg = new Config::Simple("/etc/$BASENAME");
    %CONFIG = $cfg->vars();
}

# Check for a user configuration file
if ( -e "$ENV{HOME}/.$BASENAME" ) {
    my $cfg = new Config::Simple("$ENV{HOME}/.$BASENAME");
    %CONFIG = %CONFIG, $cfg->vars();
}

my $HELP = "Unburden Home Directory

Usage: $0 [-n|-h]

  -n -- dry run (show what would be done)
  -h -- show this help
";

# Parse command line options
getopt('hn', \%OPTIONS);
if ($OPTIONS{n}) {
    $DEBUG = 1;
}

if ($OPTIONS{h}) {
    print $HELP; exit 0;;
}

# Set proper umask when creating files or directories. Save current
# umask before.
my $OLDUMASK = umask();
umask(077);

sub report_problem {
    warn "WARNING: Can't handle $_[0]: $_[1]";
}

sub report_serious_problem {
    warn "ERROR: Can't handle $_[0]: $_[1]";
}

sub create_symlink_and_parents {
    create_parent_directories($_[1]);
    $DEBUG && print join(' -> ', @_);
    symlink($_[0], $_[1]) or die "Couldn't symlink ".join(' -> ', @_).": $!";
}

sub create_parent_directories {
    make_path(dirname($_[0]), { verbose => $DEBUG });
}

sub possibly_create_non_existing_stuff {
    # Shall we create not yet existing directories or files as symlink?
    # Case 1: directory
    if ( $_[0] eq "D" ) {
	create_parent_directories($_[2]);
	create_symlink_and_parents($_[2], $_[1]);
    }

    # Case 2: file
    elsif ( $_[0] eq "F" ) {
	create_parent_directories($_[2]);
	$DEBUG && print "Touching $_[2]";
	touch($_[2]);
	create_symlink_and_parents($_[2], $_[1])
    }
    return 0
}

sub fix_dangling_links {
    my $link = readlink($_[1]);
    # Check if link target is wanted target
    if ( $link ne $_[2] ) {
	report_problem($_[1], "$link not equal $_[2]");
	return 1
    }

    # Check if target exists and is same type
    if ( -e $_[2] ) {
	# Case 1: directory
	if ( $_[0] eq "d" or $_[0] eq 'D' ) {
	    # Does target exist?
	    if ( ! -d $_[2] ) {
		report_problem($_[1], "Unexpected type (not a directory)");
		return 1
	    }
	}
	# Case 2: file
	elsif ( $_[0] eq "f" or $_[0] eq 'F' ) {
	    # Does target exist?
	    if ( ! -f $_[2] ) {
		report_problem($_[1], "Unexpected type (not a regular file)");
		return 1
	    }
	}
    }
    # Symlink is there, but file or directory not
    else {
	# Case 1: directory
	if ( $_[0] eq "d" or $_[0] eq 'D' ) {
	    make_path($_[2], { verbose => $DEBUG });
	}
	# Case 2: file
	elsif ( $_[0] eq "f" or "$_[0]" eq 'F' ) {
	    create_parent_directories($_[2]);
	    $DEBUG && print "Touching $_[2]";
	    touch($_[2]);
	}
    }
    return 0
}

sub do_it {
    if ( $_[0] eq "d" or $_[0] eq 'D' ) {
	if ( -d $_[1] ) {
	    if ( $_[3] eq "r" or $_[3] eq "d" ) {
		remove_tree($_[1], { verbose => $DEBUG });
		make_path($_[2], { verbose => $DEBUG });
	    }
	    elsif ( $_[3] eq "m" ) {
		create_parent_directories($_[2]);
		$DEBUG && print "$_[1] -> $_[2]";
		move(@_[1,2]) or die "Couldn't move $_[1] -> $_[2]: $!";
	    }
	    else {
		warn "Unknown action '$_[3]'. This should never happen.";
		return 255
	    }
	    $DEBUG && print "$_[2] ->  $_[1]";
	    symlink($_[2], $_[1]) or die "Couldn't symlink $_[2] ->  $_[1]: $!";
	}
	else {
	    report_serious_problem($_[1], "Unexpected type (not a directory)");
	    return 1
	}
    }
    elsif ( $_[0] eq "f" or $_[0] eq 'F' ) {
	if ( -f $_[1] ) {
	    if ( $_[3] eq "r" or $_[3] eq "d" ) {
		$DEBUG && print "Deleting $_[1]";
		unlink($_[1]) or die "Couldn't delete $_[1]: $!";
		create_parent_directories($_[2]);
		$DEBUG && print "Touching $_[2]";
		touch($_[2]);
	    }
	    elsif ( $_[3] eq "m" ) {
		create_parent_directories($_[2]);
		$DEBUG && print "$_[1] -> $_[2]";
		move(@_[1,2]) or die "Couldn't move $_[1] -> $_[2]: $!";
	    }
	    else {
		warn "Unknown action '$_[3]'. This should never happen.";
		return 255
	    }
	    $DEBUG && print "$_[2] ->  $_[1]";
	    symlink($_[2], $_[1]) or die "Couldn't symlink $_[2] ->  $_[1]: $!";
	}
	else {
	    report_serious_problem($_[1], "Unexpected type (not a file)");
	    return 1
	}
    }
    else {
	warn "This should never happen.";
	return 255
    }
    return 0
}

sub replace {
    # replace $type $i $item $replacement
    my $type = $_[0];
    my $itemexpanded = $_[1];
    my $itemglob = $_[2];
    my $replacement = $_[3];
    my $action = $_[4];

    # Skip entries where wildcard where passed
    if ($itemexpanded =~ /[][*?]/) {
	warn "Skipping '$itemexpanded' due to unmatched wildcard.";
	return 0
    }

    my $target = $FILELAYOUT;
    $target =~ s|%u|`id -un`|ge;
    $target =~ s|%s|$replacement|g;
    $target = "$TARGETDIR/$target";

    # Replace %<n> (e.g. %1) with the n-th wildcard match. Uses perl
    # here as it would be too complicated and way less readable if
    # written as (bourne) shell script.

	# Change from globbing to regexp
	$itemglob =~ s/\?/(.)/;
	$itemglob =~ s/\*/(.*)/;

	my @result = $itemexpanded =~ m($itemglob)g;

	$target =~ s/\%(\d+)/$result[$_[0]-1]/eg;

    # Check if the source exists
    if ( ! -e $itemexpanded and ! -l $itemexpanded ) {
	possibly_create_non_existing_stuff($type, $itemexpanded, $target);
    }
    # Check if source is already a symlink
    elsif ( -l $itemexpanded ) {
	fix_dangling_links($type, $itemexpanded, $target);
    }

    # TODO: Check available disk space
    # Should use report_serious_problem

    # No symlink yet, then actually move or remove!
    else {
	do_it($type, $itemexpanded, $target, $action);
    }
}

for my $list ("/etc/${BASENAME}_list",
	      "$ENV{HOME}/.${BASENAME}_list") {
    next unless -r $list;

    # Clean up this and that
    open(LIST, '<', $list) or die "Can't open $list: $!";
    while (<LIST>) {
	next if /^#/;

	chomp;
	my ($action, $type, $item, $replacement) = split;

	next unless defined $action;
	#next if $action eq '';

	if (!defined($item) or !defined($replacement)) {
	    warn "Can't parse '$_', skipping...";
	    next
	}
	if ( $type ne "d" and  $type ne "f" and
	     $type ne "D" and  $type ne "F" ) {
	    warn "Can't parse type '$type', must be 'd', 'D', 'f' or 'F', skipping...";
	    next
	}
	if ( $action ne "d" and $action ne "r" and $action ne "m"  ) {
	    warn "Can't parse action '$action', must be 'd', 'r' or 'm', skipping...";
	    next
	}

	for my $i (glob("$ENV{HOME}/$item")) {
	    replace($type, $i, $item, $replacement, $action);
	}
    }
}

# Restore original umask
umask($OLDUMASK);
